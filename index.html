<!DOCTYPE html>
<meta charset="UTF-8">
<title>micro:pad</title>

<style type="text/css">
* {
    font-size: 5vmin;
}
html {
    touch-action:none;
    user-select: none;
}
</style>

<body>
    <div style="position:absolute; left:10px; top:10px;">
        <button type="button" id="connect"    onclick="connectBLE()">üö©</button>
        <button type="button" id="disconnect" onclick="disconnectBLE()" disabled>üõë</button>
    </div>
    <canvas id="canvas"></canvas>
</body>

<script>

//--- connect with microbit via bluetooth.
let isConnected = false;
let uBitDevice;
let rxCharacteristic;

async function connectBLE() {
    const UART_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
    const UART_TX_CHARACTERISTIC_UUID = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";
    const UART_RX_CHARACTERISTIC_UUID = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";

    if (isConnected) return;

    try {
        console.log("Requesting Bluetooth Device...");
        uBitDevice = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: "BBC micro:bit" }],
            optionalServices: [UART_SERVICE_UUID]
        });

        uBitDevice.addEventListener('gattserverdisconnected', onDisconnected);

        console.log("Connecting to GATT Server...");
        const server = await uBitDevice.gatt.connect();

        console.log("Getting Service...");
        const service = await server.getPrimaryService(UART_SERVICE_UUID);

        console.log("Getting Characteristics...");
        const txCharacteristic = await service.getCharacteristic(UART_TX_CHARACTERISTIC_UUID);
        txCharacteristic.startNotifications();
        txCharacteristic.addEventListener("characteristicvaluechanged", onTxCharacteristicValueChanged);
        rxCharacteristic = await service.getCharacteristic(UART_RX_CHARACTERISTIC_UUID);

        isConnected = true;
        document.getElementById('connect').disabled = true;
        document.getElementById('disconnect').disabled = false;
        console.log("Connected");
    } catch (error) {
        console.log(error);
    }
}

function disconnectBLE() {
    if (!uBitDevice) return;
    
    if (uBitDevice.gatt.connected) {
    uBitDevice.gatt.disconnect();
  }
}

// called when disconnected.
function onDisconnected(event) {
    let device = event.target;
    console.log(`Device ${device.name} is disconnected.`);
    isConnected = false;
    document.getElementById('connect').disabled = false;
    document.getElementById('disconnect').disabled = true;
    console.log("Disconnected");
}

// send cmd and micro:bit receive data.
async function sendCmd(cmd) {
    // write log when micro:bit is not connected.
    if (!isConnected) {
        console.log(cmd);
        return;
    }
    
    enqueue(() => rxCharacteristic.writeValue(encoder.encode(cmd + "\n"))
        .catch(error => console.error('error occured while writeValue:', error)));
}
const encoder = new TextEncoder();

function enqueue(operation) {
   queue = queue.then(operation, operation);
   return queue;
}
let queue = Promise.resolve();

// called when micro:bit send data.
function onTxCharacteristicValueChanged(event) {
	let receivedData = [];
	for (var i = 0; i < event.target.value.byteLength; i++) {
		receivedData[i] = event.target.value.getUint8(i);
	}

	const receivedString = String.fromCharCode.apply(null, receivedData);
	console.log(receivedString);
}

//--- user interface.

class AnalogStick {
    // ÂàùÊúüÂåñ
    constructor(canvas, context) {
        this.canvas = canvas;
        this.context = context;

        // ‰∏≠ÂøÉÂ∫ßÊ®ô„ÄÇ
        this.setPosition(this.canvas.width / 2, this.canvas.height / 2);

        // „Çª„É≥„Çø„ÉºÂéüÁÇπ„Åß„ÅÆÂ∫ßÊ®ô„ÄÇ
        this.posX = 0;
        this.posY = 0;

        // ÂÜÜ„ÅÆË°®Á§∫„ÄÇ
        this.largeRadiusScale = 0.1;
        this.smallRadiusScale = 0.05;
        this.largeRadiusStyle = 'gray';
        this.smallRadiusStyle = 'blue';

        this.onChange = () => {}; // null guard.

        // „Éû„Ç¶„Çπ„Ç§„Éô„É≥„Éà„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´„ÄÇ
        this.installMouseEvent();
    }

    get large_radius() {
        return (this.canvas.width > this.canvas.height)?
            this.canvas.width * this.largeRadiusScale:
            this.canvas.height * this.largeRadiusScale;
    }
    get small_radius() {
        return (this.canvas.width > this.canvas.height)?
            this.canvas.width * this.smallRadiusScale:
            this.canvas.height * this.smallRadiusScale;
    }

    get width()  { return 2 * this.large_radius; }
    get height() { return 2 * this.large_radius; }

    setPosition(x, y) {
        this.centerX = x;
        this.centerY = y;
    }

    // mousemove, mousedown, mouseup„Ç§„Éô„É≥„Éà„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´„ÄÇ
    // „Éû„É´„ÉÅ„Çø„ÉÉ„ÉÅÂØæÂøú„Åß„Åç„Çã„Çà„ÅÜ„Å´„ÄÅpointer„Ç§„Éô„É≥„Éà„Å´Â§âÊõ¥„ÄÇ
    installMouseEvent() {
        this.mousedown = false;
        this.pointerId = 0;

        window.addEventListener('pointerdown', ev => {
            if (this.mouse_Drag(ev.offsetX, ev.offsetY, false)) { // clientX, clientY„Å†„Å®„Éï„Ç©„Éº„É†„ÅÆÂàÜ„Åö„Çå„Åü„ÄÇ
                this.mousedown = true;
                this.pointerId = ev.pointerId;
                this.mouse_Down();
            }
        });

        window.addEventListener('pointermove', ev => {
            if (this.mousedown && this.pointerId == ev.pointerId) {
                this.mouse_Drag(ev.offsetX, ev.offsetY, true);
                //console.log(this.name, "this.stickAngle", this.stickAngle, "this.stickPower", this.stickPower);
            }
        });

        window.addEventListener('pointerup', ev => {
            if (this.pointerId == ev.pointerId) {
                this.mousedown = false;
                this.pointerId = 0;
                this.mouse_Up();
                //console.log(this.name, "this.stickAngle", this.stickAngle, "this.stickPower", this.stickPower);
            }
        });
    }

    update() {
        // do nothing.
    }

    mouse_Down() {
        //console.log("mouse_Down");
    }

    mouse_Drag(x, y, updateStick) {
        //console.log("mouse_Drag");

        // „Çª„É≥„Çø„ÉºÂéüÁÇπ„Åß„ÅÆÂ∫ßÊ®ô„Å´Â§âÊèõ„ÄÇ
        const local_x =  x - this.centerX;
        const local_y =  y - this.centerY;
        const local_x2 = local_x * local_x;
        const local_y2 = local_y * local_y;

        const large_radius = this.large_radius;
        const touch_radius = Math.min(Math.sqrt(local_x2 + local_y2), large_radius);
        
        // Â§ß„Åç„Å™ÂÜÜ„ÅÆÂÜÖÂÅ¥„ÅãÔºü
        const inside_radius_max = (local_x2 + local_y2 < large_radius * large_radius);

        if (updateStick) {
            // power„Å®angle„ÇíÊ±Ç„ÇÅ„Çã„ÄÇ
            let power = touch_radius / large_radius;  // ‰∏≠ÂøÉ„Åã„Çâ„Å©„Çå„Åè„Çâ„ÅÑÈõ¢„Çå„Å¶„ÅÑ„Çã„Åã„ÄÇ0.0-1.0„ÄÇ
            let angle = Math.atan2(local_y, local_x); // XÂ∫ßÊ®ô„Åã„ÇâÊôÇË®àÂõû„Çä„É©„Ç∏„Ç¢„É≥„ÄÇ-œÄÔΩû+œÄ„ÄÇ
            if (angle < 0) angle += 2*Math.PI;        // 0ÔΩû2œÄ„Å´Â§âÊèõ„ÄÇ

            // ÁîªÈù¢„ÅÆË°®Á§∫‰ΩçÁΩÆ„ÅÆÊõ¥Êñ∞„ÄÇ
            this.posX = Math.cos(angle) * touch_radius;
            this.posY = Math.sin(angle) * touch_radius;
            
            // Â∞ë„ÅóÂãï„Åè„Åî„Å®„Å´onChange„Åõ„Åö„ÄÅÂ§âÂåñ„Åó„Åü„ÇâonChanged„Åô„Çã„ÄÇ
            let changed = false;
            let angle8 = 0; // angle8ÊñπÂêë„ÄÇ
            let power3 = 0; // power3ÊÆµÈöé„ÄÇ

            // power„ÅØ3ÊÆµÈöé„Å´Âà∂Èôê„Åô„Çã„ÄÇ
            if      (power < 0.33)  power3 = 0;
            else if (power < 0.66)  power3 = 0.5;
            else power3 = 1;
            if (this.power3_Prev != power3) {
                this.power3_Prev = power3;
                changed = true;
            }

            // power„ÅÇ„ÇãÊôÇ„Å†„ÅëangleÂà§ÂÆö„ÄÇ
            if (power3 != 0) {
                // angle„ÅØ8ÊñπÂêë„Å´Âà∂Èôê„Åô„Çã„ÄÇ
                if      (1  * Math.PI / 8 <= angle && angle < 3  * Math.PI / 8) angle8 = 2  * Math.PI / 8;
                else if (3  * Math.PI / 8 <= angle && angle < 5  * Math.PI / 8) angle8 = 4  * Math.PI / 8;
                else if (5  * Math.PI / 8 <= angle && angle < 7  * Math.PI / 8) angle8 = 6  * Math.PI / 8;
                else if (7  * Math.PI / 8 <= angle && angle < 9  * Math.PI / 8) angle8 = 8  * Math.PI / 8;
                else if (9  * Math.PI / 8 <= angle && angle < 11 * Math.PI / 8) angle8 = 10 * Math.PI / 8;
                else if (11 * Math.PI / 8 <= angle && angle < 13 * Math.PI / 8) angle8 = 12 * Math.PI / 8;
                else if (13 * Math.PI / 8 <= angle && angle < 15 * Math.PI / 8) angle8 = 14 * Math.PI / 8;
                else angle8 = 0;
                angle8 = Math.round(angle8 * 100) / 100; // 3.14„ÅÆ„Çà„ÅÜ„Å´Â∞ëÊï∞Á¨¨2‰Ωç„ÅßÂõõÊç®‰∫îÂÖ•„ÄÇ
                if (this.angle8_Prev != angle8) {
                    this.angle8_Prev = angle8;
                    changed = true;
                }
            }

            if (changed) {
                this.onChange(angle8, power3);
            }
        }

        return inside_radius_max;
    }

    mouse_Up() {
        //console.log("mouse_Up");

        // Ë°®Á§∫‰ΩçÁΩÆ„ÇíÂéüÁÇπ„Å´Êàª„Åô„ÄÇ
        this.posX = 0;
        this.posY = 0;

        this.onChange(0, 0);
    }

    draw() {

        // Â§ß„Åç„Å™ÂÜÜ„Çí„Çª„É≥„Çø„Éº„Å´„ÄÇ
        this.context.save();
        {
            this.context.fillStyle = this.largeRadiusStyle;
            this.context.globalAlpha = 0.5; // 50%„ÅÆÈÄèÊòéÂ∫¶

            this.context.translate(this.centerX, this.centerY)
            this.context.beginPath();
            this.context.arc(0, 0, this.large_radius, 0, 2 * Math.PI);
            this.context.closePath();
            this.context.fill();
        }
        this.context.restore();

        // Â∞è„Åï„Å™ÂÜÜ„Çí„Çª„É≥„Çø„Éº‰∏≠ÂøÉ„Åß(pos_x, pos_y)„Å´„ÄÇ
        this.context.save();
        {
            this.context.fillStyle = this.smallRadiusStyle;
            this.context.globalAlpha = 0.5; // 50%„ÅÆÈÄèÊòéÂ∫¶

            this.context.translate(this.centerX, this.centerY)
            this.context.translate(this.posX, this.posY)
            this.context.beginPath();
            this.context.arc(0, 0, this.small_radius, 0, 2 * Math.PI);
            this.context.closePath();
            this.context.fill();
        }
        this.context.restore();
    }
}

class Button {
    // ÂàùÊúüÂåñ
    constructor(canvas, context) {
        this.canvas = canvas;
        this.context = context;

        // Ë°®Á§∫„ÄÇ
        this.fontName = `Candara`;
        this.fontSize = this.canvas.width / 10;
        this.fontFillStyle = "blue";   // text color.
        this.fontStrokeStyle = "blue"; // not used.
        this.textAlign = 'center';
        this.textBaseline = 'middle';
        this.backFillStyle = 'LightCyan';     // button back
        this.backActiveStyle = 'LightSkyBlue' // button back(active)
        this.backStrokeStyle = "blue";        // button border.
        this.text = "button";

        // ‰∏≠ÂøÉÂ∫ßÊ®ô„ÄÇ(width, height„ÇÇÊõ¥Êñ∞„ÄÇ)
        this.setPosition(this.canvas.width / 2, this.canvas.height / 2);

        // Áä∂ÊÖã„ÄÇ
        this.toggle = false;
        this.checked = false;
        this.onChange = () => {}; // null guard.

        // „Éû„Ç¶„Çπ„Ç§„Éô„É≥„Éà„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´„ÄÇ
        this.installMouseEvent();
    }

    get is_active() {
        if (this.toggle) return this.checked;
        else return this.mousedown;
    }

    setPosition(x, y) {
        this.centerX = x;
        this.centerY = y;
        this.updateSize();
    }

    updateSize() {
        const size = Math.max(this.canvas.width, this.canvas.height);
        this.fontSize = size / 10;

        // ÊèèÁîª„Çµ„Ç§„Ç∫„ÇíÂèñÂæó„Åô„Çã„ÄÇ
        this.context.save();
        this.context.font = `${this.fontSize}px ${this.fontName}`;
        const metrics = this.context.measureText(this.text);
        const metrics1 = this.context.measureText(' '); // ‰∏ÄÊñáÂ≠óÂàÜ„ÄÇ
        this.context.restore();

        // „Çµ„Ç§„Ç∫„ÇíÂèñÂæó„Åô„Çã„ÄÇ
        this.width = metrics.width;
        this.height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
        this.width += metrics1.width;  // Áã≠„ÅÑ„ÅÆ„Åß1ÊñáÂ≠óÂàÜÂ∫É„Åè„ÄÇ
        this.height += metrics1.width; // Áã≠„ÅÑ„ÅÆ„Åß1ÊñáÂ≠óÂàÜÂ∫É„Åè„ÄÇ
    }

    // mousemove, mousedown, mouseup„Ç§„Éô„É≥„Éà„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´„ÄÇ
    // „Éû„É´„ÉÅ„Çø„ÉÉ„ÉÅÂØæÂøú„Åß„Åç„Çã„Çà„ÅÜ„Å´„ÄÅpointer„Ç§„Éô„É≥„Éà„Å´Â§âÊõ¥„ÄÇ
    installMouseEvent() {
        this.mousedown = false;
        this.pointerId = 0;

        window.addEventListener('pointerdown', ev => {
            if (this.is_mouse_over(ev.offsetX, ev.offsetY)) {
                this.mousedown = true;
                this.pointerId = ev.pointerId;

                if (!this.toggle) {
                    this.onChange(true);
                } else {
                    this.checked = !this.checked;
                    this.onChange(this.checked);
                }
            }
        });

        window.addEventListener('pointerup', ev => {
            if (this.mousedown = true && this.pointerId == ev.pointerId) {
                this.mousedown = false;
                this.pointerId = 0;
                
                if (!this.toggle) {
                    this.onChange(false);
                }
            }
        });
    }

    is_mouse_over(x, y) {
        const l = this.centerX - this.width / 2;
        const r = this.centerX + this.width / 2;
        const t = this.centerY - this.height / 2;
        const b = this.centerY + this.height / 2;
        return (l < x && x < r && t < y && y < b);
    }

    update() {
        // do nothing.
    }

    draw() {
        this.context.save();
        {
            // ‰∏≠ÂøÉ„ÇíÁßªÂãï„ÄÇ
            this.context.translate(this.centerX, this.centerY);

            // Ëßí‰∏∏„ÇíÊèèÁîª„ÄÇ
            this.context.lineWidth = this.height * (this.is_active? 0.1: 0.02); // this.width„ÅØ‰∏çËá™ÁÑ∂„ÄÇthis.height„Çí‰Ωø„ÅÜ„ÄÇ
            this.context.fillStyle = this.is_active? this.backActiveStyle: this.backFillStyle;
            this.context.strokeStyle = this.backStrokeStyle;
            this.roundedRect(0, 0, this.width, this.height, this.height*0.2);

            // „ÉÜ„Ç≠„Çπ„Éà„ÇíÊèèÁîª„ÄÇ
            this.context.fillStyle = this.fontFillStyle;
            this.context.strokeStyle = this.fontStrokeStyle;
            this.context.font = `${this.fontSize}px ${this.fontName}`;
            this.context.textAlign = this.textAlign;
            this.context.textBaseline = this.textBaseline;
            this.context.fillText(this.text, 0, this.height*0.1);
        }
        this.context.restore();
    }

    roundedRect(center_x, center_y, width, height, radius) {
        const x = center_x - width / 2;
        const y = center_y - height / 2;
        this.context.save();
        this.context.beginPath();
        this.context.moveTo(x, y + radius);
        this.context.arcTo(x, y + height, x + radius, y + height, radius);
        this.context.arcTo(x + width, y + height, x + width, y + height - radius, radius);
        this.context.arcTo(x + width, y, x + width - radius, y, radius);
        this.context.arcTo(x, y, x, y + radius, radius);
        this.context.closePath();
        this.context.stroke(); // Êû†Á∑ö„ÇíÊèèÁîª„ÄÇ
        this.context.fill(); // Â°ó„Çä„Å§„Å∂„Åô„ÄÇ
        this.context.restore();
    }
}

class Slider {
    // ÂàùÊúüÂåñ
    constructor(canvas, context) {
        this.canvas = canvas;
        this.context = context;

        // ‰∏≠ÂøÉÂ∫ßÊ®ô„ÄÇ
        this.setPosition(
            this.canvas.width / 2,
            this.canvas.height / 2,
            this.canvas.width * 0.2
        );

        // Ë°®Á§∫„ÄÇ
        this.lineWidth = 0.05;
        this.knobScale = 0.05;
        this.lineStyle = 'gray';
        this.knobStyle = 'blue';

        this.onChange = () => {}; // null guard.

        // „Éû„Ç¶„Çπ„Ç§„Éô„É≥„Éà„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´„ÄÇ
        this.installMouseEvent();
    }

    setPosition(x, y, width) {
        this.centerX = x;
        this.centerY = y;
        this.sliderWidth = width;
        this.sliderLeft  = this.centerX - (this.sliderWidth / 2);
        this.sliderRight = this.centerX + (this.sliderWidth / 2);
    }

    // mousemove, mousedown, mouseup„Ç§„Éô„É≥„Éà„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´„ÄÇ
    // „Éû„É´„ÉÅ„Çø„ÉÉ„ÉÅÂØæÂøú„Åß„Åç„Çã„Çà„ÅÜ„Å´„ÄÅpointer„Ç§„Éô„É≥„Éà„Å´Â§âÊõ¥„ÄÇ
    installMouseEvent() {
        this.mousedown = false;
        this.pointerId = 0;

        window.addEventListener('pointerdown', ev => {
            if (this.mouse_Drag(ev.offsetX, ev.offsetY, false)) { // clientX, clientY„Å†„Å®„Éï„Ç©„Éº„É†„ÅÆÂàÜ„Åö„Çå„Åü„ÄÇ
                this.mousedown = true;
                this.pointerId = ev.pointerId;
                this.mouse_Down();
            }
        });

        window.addEventListener('pointermove', ev => {
            if (this.mousedown && this.pointerId == ev.pointerId) {
                this.mouse_Drag(ev.offsetX, ev.offsetY, true);
                //console.log(this.name, "this.stickAngle", this.stickAngle, "this.stickPower", this.stickPower);
            }
        });

        window.addEventListener('pointerup', ev => {
            if (this.pointerId == ev.pointerId) {
                this.mousedown = false;
                this.pointerId = 0;
                this.mouse_Up();
                //console.log(this.name, "this.stickAngle", this.stickAngle, "this.stickPower", this.stickPower);
            }
        });
    }

    update() {
        // do nothing.
    }

    mouse_Down() {
        //console.log("mouse_Down");
    }

    mouse_Drag(x, y, updateStick) {
        //console.log("mouse_Drag");

        // „Ç§„É≥„Ç∏„Ç±„Éº„Çø„ÉºÂéüÁÇπ„Åß„ÅÆÂ∫ßÊ®ô„Å´Â§âÊèõ„ÄÇ
        const local_x =  x - this.centerX;
        const local_y =  y - this.centerY;
        const local_x2 = local_x * local_x;
        const local_y2 = local_y * local_y;

        const width = this.canvas.width;
        const height = this.canvas.height;
        const radius = (width > height)? width * this.knobScale: height * this.knobScale;
        
        // „Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº„ÅÆÂÜÖÂÅ¥„ÅãÔºü
        const inside_radius = (local_x2 + local_y2 < radius * radius);

        if (updateStick) {
            // Ë°®Á§∫‰ΩçÁΩÆ„ÅÆÊõ¥Êñ∞„ÄÇ„ÅØ„ÅøÂá∫„Åü„ÇâÊàª„Åô„ÄÇ
            this.centerX = x;
            if (this.centerX < this.sliderLeft)  this.centerX = this.sliderLeft;
            if (this.centerX > this.sliderRight) this.centerX = this.sliderRight;

            // ‰ΩçÁΩÆ„ÅÆË®àÁÆó„ÄÇ
            const power = this.centerX - this.sliderLeft;
            let value = power / this.sliderWidth;
            value = Math.round(value * 10) / 10; // Â∞ëÊï∞Á¨¨1‰Ωç„ÅßÂõõÊç®‰∫îÂÖ•„ÄÇ
            if (this.value_Prev != value) {
                this.value_Prev = value;
                this.onChange(value);
            }
        }

        return inside_radius;
    }

    mouse_Up() {
        //console.log("mouse_Up");
    }

    draw() {
        const width = this.canvas.width;
        const height = this.canvas.height;

        // „É©„Ç§„É≥„ÄÇ
        this.context.save();
        {
            this.context.strokeStyle = this.lineStyle;
            this.context.globalAlpha = 0.5; // ÈÄèÊòéÂ∫¶

            this.context.lineWidth = height * this.lineWidth;
            context.lineCap = 'round';
            this.context.beginPath();
            this.context.moveTo(this.sliderLeft, this.centerY);
            this.context.lineTo(this.sliderRight, this.centerY);
            this.context.stroke();
            this.context.closePath();
        }
        this.context.restore();

        // Â∞è„Åï„Å™ÂÜÜ„ÄÇ
        this.context.save();
        {
            this.context.fillStyle = this.knobStyle;
            this.context.globalAlpha = 0.9; // ÈÄèÊòéÂ∫¶

            this.context.translate(this.centerX, this.centerY)
            this.context.beginPath();
            const radius = (width > height)? width * this.knobScale: height * this.knobScale;
            this.context.arc(0, 0, radius, 0, 2 * Math.PI);
            this.context.closePath();
            this.context.fill();
        }
        this.context.restore();
    }
}

// suppress context menu.
document.oncontextmenu = () => false;

const canvas = document.querySelector('#canvas');
const context = canvas.getContext('2d');
const controls = initControl();

// start animation.
requestAnimationFrame(updateFrame);

// update frame.
function updateFrame() {
    update();
    draw();
    requestAnimationFrame(updateFrame);
}

// init controls.
function initControl() {
    let result = [];

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });

    // AnalogStick 1.
    const stick1 = new AnalogStick(canvas, context);
    stick1.onChange = (angle, power) => {
        const cmd = `a1,${angle},${power}`;
        sendCmd(cmd)
    };
    result.push(stick1);
    window.addEventListener('resize', () => {
        stick1.setPosition(canvas.width * 0.25, canvas.height / 2);
    });

    // AnalogStick 2.
    const stick2 = new AnalogStick(canvas, context);
    stick2.onChange = (angle, power) => {
        const cmd = `a2,${angle},${power}`;
        sendCmd(cmd)
    };
    result.push(stick2);
    window.addEventListener('resize', () => {
        stick2.setPosition(canvas.width * 0.75, canvas.height / 2);
    });

    // Button 1.
    const button1 = new Button(canvas, context);
    button1.text = "X";
    button1.onChange = (flag) => {
        const cmd = `b1,${flag? 1: 0},0`;
        sendCmd(cmd)
    };
    result.push(button1);
    window.addEventListener('resize', () => {
        button1.setPosition(canvas.width * 0.2, canvas.height / 2 + stick1.height * 0.75);
    });

    // Button 2.
    const button2 = new Button(canvas, context);
    button2.text = "Y";
    button2.toggle = true;
    button2.onChange = (flag) => {
        const cmd = `b2,${flag? 1: 0},0`;
        sendCmd(cmd)
    };
    result.push(button2);
    window.addEventListener('resize', () => {
        button2.setPosition(canvas.width * 0.8, canvas.height / 2 + stick2.height * 0.75);
    });

    // Slider.
    const slider1 = new Slider(canvas, context);
    slider1.knobStyle = 'orange';
    slider1.onChange = (value) => {
        const cmd = `s1,${value},0`;
        sendCmd(cmd)
    };
    result.push(slider1);
    window.addEventListener('resize', () => {
        slider1.setPosition(canvas.width * 0.5, canvas.height / 2 - stick2.height * 0.75, canvas.width * 0.75);
    });

    // trigger 'resize' event to layout control.
    window.dispatchEvent(new Event('resize'));

    return result;
}

function update() {
    // update all controls.
    for(let item of controls) {
        item.update();
    }
}

function draw() {    
    // clear screen.
    context.clearRect(0, 0, canvas.width, canvas.height);
    canvas.style.backgroundColor = "AliceBlue";

    // draw all controls.
    for(let item of controls) {
        item.draw();
    }
}

</script>
