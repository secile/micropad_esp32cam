<!DOCTYPE html>
<meta charset="UTF-8">
<title>micro:pad</title>

<style type="text/css">
* {
    font-size: 3vmin;
}
</style>

<body>
    <div style="position:absolute; left:10px; top:10px;">
        <button type="button" id="connect"    onclick="connectBLE()">ğŸš©</button>
        <button type="button" id="disconnect" onclick="disconnectBLE()" disabled>ğŸ›‘</button>
    </div>
    <canvas id="canvas"></canvas>
</body>

<script>

//--- connect with microbit via bluetooth.
let isConnected = false;
let uBitDevice;
let rxCharacteristic;

async function connectBLE() {
    const UART_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
    const UART_TX_CHARACTERISTIC_UUID = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";
    const UART_RX_CHARACTERISTIC_UUID = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";

    if (isConnected) return;

    try {
        console.log("Requesting Bluetooth Device...");
        uBitDevice = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: "BBC micro:bit" }],
            optionalServices: [UART_SERVICE_UUID]
        });

        uBitDevice.addEventListener('gattserverdisconnected', onDisconnected);

        console.log("Connecting to GATT Server...");
        const server = await uBitDevice.gatt.connect();

        console.log("Getting Service...");
        const service = await server.getPrimaryService(UART_SERVICE_UUID);

        console.log("Getting Characteristics...");
        const txCharacteristic = await service.getCharacteristic(UART_TX_CHARACTERISTIC_UUID);
        txCharacteristic.startNotifications();
        txCharacteristic.addEventListener("characteristicvaluechanged", onTxCharacteristicValueChanged);
        rxCharacteristic = await service.getCharacteristic(UART_RX_CHARACTERISTIC_UUID);

        isConnected = true;
        document.getElementById('connect').disabled = true;
        document.getElementById('disconnect').disabled = false;
        console.log("Connected");
    } catch (error) {
        console.log(error);
    }
}

function disconnectBLE() {
    if (!uBitDevice) return;
    
    if (uBitDevice.gatt.connected) {
    uBitDevice.gatt.disconnect();
  }
}

// called when disconnected.
function onDisconnected(event) {
    let device = event.target;
    console.log(`Device ${device.name} is disconnected.`);
    isConnected = false;
    document.getElementById('connect').disabled = false;
    document.getElementById('disconnect').disabled = true;
    console.log("Disconnected");
}

// send cmd and micro:bit receive data.
async function sendCmd(num) {
    if (!rxCharacteristic) return;
    
    let encoder = new TextEncoder();
    enqueue(() => rxCharacteristic.writeValue(encoder.encode(num + "\n"))
        .catch(error => console.error('error occured while writeValue:', error)));
}

let queue = Promise.resolve();

function enqueue(operation) {
   queue = queue.then(operation, operation);
   return queue;
}

// called when micro:bit send data.
function onTxCharacteristicValueChanged(event) {
	let receivedData = [];
	for (var i = 0; i < event.target.value.byteLength; i++) {
		receivedData[i] = event.target.value.getUint8(i);
	}

	const receivedString = String.fromCharCode.apply(null, receivedData);
	console.log(receivedString);
}

//--- user interface.

class Stick {
    // åˆæœŸåŒ–
    constructor(canvas, context) {
        this.canvas = canvas;
        this.context = context;

        // ä¸­å¿ƒåº§æ¨™ã€‚
        this.centerX = this.canvas.width / 2;
        this.centerY = this.canvas.height / 2;

        // ã‚»ãƒ³ã‚¿ãƒ¼åŸç‚¹ã§ã®åº§æ¨™ã€‚
        this.posX = 0;
        this.posY = 0;

        // å††ã®è¡¨ç¤ºã€‚
        this.largeRadiusScale = 0.1;
        this.smallRadiusScale = 0.05;
        this.largeRadiusStyle = 'gray';
        this.smallRadiusStyle = 'blue';

        // ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ…‹ã€‚
        this.stickAngle = 0; // 0.0-2piã€‚(Xåº§æ¨™ã‹ã‚‰æ™‚è¨ˆå›ã‚Šãƒ©ã‚¸ã‚¢ãƒ³)
        this.stickPower = 0; // 0.0-1.0ã€‚

        this.onChange = () => {}; // null guard.

        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã€‚
        this.installMouseEvent();
    }

    // mousemove, mousedown, mouseupã‚¤ãƒ™ãƒ³ãƒˆã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã€‚
    // ãƒãƒ«ãƒã‚¿ãƒƒãƒå¯¾å¿œã§ãã‚‹ã‚ˆã†ã«ã€pointerã‚¤ãƒ™ãƒ³ãƒˆã«å¤‰æ›´ã€‚
    installMouseEvent() {
        this.mousedown = false;
        this.pointerId = 0;

        window.addEventListener('pointerdown', ev => {
            if (this.mouse_Drag(ev.offsetX, ev.offsetY, false)) { // clientX, clientYã ã¨ãƒ•ã‚©ãƒ¼ãƒ ã®åˆ†ãšã‚ŒãŸã€‚
                this.mousedown = true;
                this.pointerId = ev.pointerId;
                this.mouse_Down();
            }
        });

        window.addEventListener('pointermove', ev => {
            if (this.mousedown && this.pointerId == ev.pointerId) {
                this.mouse_Drag(ev.offsetX, ev.offsetY, true);
                //console.log(this.name, "this.stickAngle", this.stickAngle, "this.stickPower", this.stickPower);
            }
        });

        window.addEventListener('pointerup', ev => {
            if (this.pointerId == ev.pointerId) {
                this.mousedown = false;
                this.pointerId = 0;
                this.mouse_Up();
                //console.log(this.name, "this.stickAngle", this.stickAngle, "this.stickPower", this.stickPower);
            }
        });
    }

    update() {
        // do nothing.
    }

    mouse_Down() {
        //console.log("mouse_Down");
    }

    mouse_Drag(x, y, updateStick) {
        //console.log("mouse_Drag");

        // ã‚»ãƒ³ã‚¿ãƒ¼åŸç‚¹ã§ã®åº§æ¨™ã«å¤‰æ›ã€‚
        const local_x =  x - this.centerX;
        const local_y =  y - this.centerY;
        const local_x2 = local_x * local_x;
        const local_y2 = local_y * local_y;

        const width = this.canvas.width;
        const height = this.canvas.height;
        const radius_max = (width > height)? width * this.largeRadiusScale: height * this.largeRadiusScale;
        const radius = Math.min(Math.sqrt(local_x2 + local_y2), radius_max);
        
        // å¤§ããªå††ã®å†…å´ã‹ï¼Ÿ
        const inside_radius_max = (local_x2 + local_y2 < radius_max * radius_max);

        if (updateStick) {
            // å°‘ã—å‹•ãã”ã¨ã«onChangeã›ãšã€å¤‰åŒ–ã—ãŸã‚‰onChangedã™ã‚‹ã€‚
            let changed = false;

            // powerã¨angleã‚’æ±‚ã‚ã‚‹ã€‚
            let power = radius / radius_max;
            let angle = Math.atan2(local_y, local_x); // Xåº§æ¨™ã‹ã‚‰æ™‚è¨ˆå›ã‚Šãƒ©ã‚¸ã‚¢ãƒ³ã€‚-Ï€ï½+Ï€ã€‚
            if (angle < 0) angle += 2*Math.PI;        // 0ï½2Ï€ã«å¤‰æ›ã€‚

            // ç”»é¢ã®è¡¨ç¤ºä½ç½®ã®æ›´æ–°ã€‚
            this.posX = Math.cos(angle) * radius;
            this.posY = Math.sin(angle) * radius;

            // powerã¯3æ®µéšã«åˆ¶é™ã™ã‚‹ã€‚
            if      (power < 0.33)  this.stickPower = 0;
            else if (power < 0.66)  this.stickPower = 0.5;
            else this.stickPower = 1;
            if (this.stickPower_Prev != this.stickPower) {
                this.stickPower_Prev = this.stickPower;
                changed = true;
            }

            // powerã‚ã‚‹æ™‚ã ã‘angleåˆ¤å®šã€‚
            if (this.stickPower != 0) {
                // angleã¯8æ–¹å‘ã®ã¿ã«åˆ¶é™ã™ã‚‹ã€‚
                if      (1  * Math.PI / 8 <= angle && angle < 3  * Math.PI / 8) this.stickAngle = 2  * Math.PI / 8;
                else if (3  * Math.PI / 8 <= angle && angle < 5  * Math.PI / 8) this.stickAngle = 4  * Math.PI / 8;
                else if (5  * Math.PI / 8 <= angle && angle < 7  * Math.PI / 8) this.stickAngle = 6  * Math.PI / 8;
                else if (7  * Math.PI / 8 <= angle && angle < 9  * Math.PI / 8) this.stickAngle = 8  * Math.PI / 8;
                else if (9  * Math.PI / 8 <= angle && angle < 11 * Math.PI / 8) this.stickAngle = 10 * Math.PI / 8;
                else if (11 * Math.PI / 8 <= angle && angle < 13 * Math.PI / 8) this.stickAngle = 12 * Math.PI / 8;
                else if (13 * Math.PI / 8 <= angle && angle < 15 * Math.PI / 8) this.stickAngle = 14 * Math.PI / 8;
                else this.stickAngle = 0;
                this.stickAngle = Math.round(this.stickAngle * 100) / 100; // 3.14ã®ã‚ˆã†ã«å°‘æ•°ç¬¬2ä½ã§å››æ¨äº”å…¥ã€‚
                if (this.stickAngle_Prev != this.stickAngle) {
                    this.stickAngle_Prev = this.stickAngle;
                    changed = true;
                }
            }

            if (changed) {
                this.onChange();
            }
        }

        return inside_radius_max;
    }

    mouse_Up() {
        //console.log("mouse_Up");

        // ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’åŸç‚¹ã«æˆ»ã™ã€‚
        this.stickPower = 0;
        this.stickAngle = 0;

        // è¡¨ç¤ºä½ç½®ã‚’åŸç‚¹ã«æˆ»ã™ã€‚
        this.posX = 0;
        this.posY = 0;

        this.onChange();
    }

    draw() {
        const width = this.canvas.width;
        const height = this.canvas.height;

        // å¤§ããªå††ã‚’ã‚»ãƒ³ã‚¿ãƒ¼ã«ã€‚
        this.context.save();
        {
            this.context.fillStyle = this.largeRadiusStyle;
            this.context.globalAlpha = 0.5; // 50%ã®é€æ˜åº¦

            this.context.translate(this.centerX, this.centerY)
            this.context.beginPath();
            const radius = (width > height)? width * this.largeRadiusScale: height * this.largeRadiusScale;
            this.context.arc(0, 0, radius, 0, 2 * Math.PI);
            this.context.closePath();
            this.context.fill();
        }
        this.context.restore();

        // å°ã•ãªå††ã‚’ã‚»ãƒ³ã‚¿ãƒ¼ä¸­å¿ƒã§(pos_x, pos_y)ã«ã€‚
        this.context.save();
        {
            this.context.fillStyle = this.smallRadiusStyle;
            this.context.globalAlpha = 0.5; // 50%ã®é€æ˜åº¦

            this.context.translate(this.centerX, this.centerY)
            this.context.translate(this.posX, this.posY)
            this.context.beginPath();
            const radius = (width > height)? width * this.smallRadiusScale: height * this.smallRadiusScale;
            this.context.arc(0, 0, radius, 0, 2 * Math.PI);
            this.context.closePath();
            this.context.fill();
        }
        this.context.restore();
    }
}

let canvas, context;
let controlls = [];

setup();

// start animation.
requestAnimationFrame(updateFrame);

window.addEventListener('resize', () => setup());

function setup() {
    canvas = document.querySelector('#canvas');
    context = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    initControl();
}

function initControl() {
    const stick1 = new Stick(canvas, context);
    stick1.centerX = canvas.width * 0.25;
    stick1.onChange = () => {
        const cmd = `s1,${stick1.stickAngle},${stick1.stickPower}`;
        console.log(cmd);
        this.sendCmd(cmd)
    };

    const stick2 = new Stick(canvas, context);
    stick2.centerX = canvas.width * 0.75;
    stick2.onChange = () => {
        const cmd = `s2,${stick2.stickAngle},${stick2.stickPower}`;
        console.log(cmd);
        this.sendCmd(cmd)
    };

    controlls = [stick1, stick2];
}

function update() {
    // update all controls.
    for(let item of controlls) {
        item.update();
    }
}

function draw() {    
    // clear screen.
    context.clearRect(0, 0, canvas.width, canvas.height);
    canvas.style.backgroundColor = "AliceBlue";

    // draw all controls.
    for(let item of controlls) {
        item.draw();
    }
}

// update frame.
function updateFrame() {
    update();
    draw();
    requestAnimationFrame(updateFrame);
}

</script>
